<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>esmspy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" />
    <style>
      html {
        box-sizing: border-box;
      }
      *, *:before, *:after {
        box-sizing: inherit;
      }
      body {
        background-color: lightgray;
        font-family: sans-serif;
      }
      html, body {
        height: 100%;
      }
    </style>
    <script>
      (() => {
        const href = sessionStorage.getItem('github-404-href');
        sessionStorage.removeItem('github-404-href');
        if (href && href !== location.href) {
          history.replaceState(null, null, href);
        }
      })();
    </script>
  </head>
  <body>
    <script type="module">
      import Htm from 'https://unpkg.com/htm@3.0.4/dist/htm.module.js'
      import{h, render} from 'https://cdn.pika.dev/preact@10.4.4';
      import {useState, useEffect} from 'https://cdn.pika.dev/preact@10.4.4/hooks';
      import {styled, setPragma} from 'https://unpkg.com/goober@1.8.0/dist/goober.module.js'
      import PrettyBytes from 'https://cdn.pika.dev/pretty-bytes@5.3.0'

      import {Router, Link, route} from '/js/preact-router.js'

      const html = Htm.bind(h)
      setPragma(h)

      function urlToStoragePath(url) {
        const { protocol, host, pathname, search } = new URL(url);
        const [, ...paths] = pathname.split('/');
        const encodedPaths = paths.flatMap((path) => {
          const [firstPath, ...ats] = path.split('@');
          return [`p:${firstPath}`, ...ats.map((at) => `a:${at}`)];
        });
        const urlWithoutProtocol = url.substring(`${protocol}//`.length);
        const trailingSlashWasAdded = !urlWithoutProtocol.includes('/') && encodedPaths[0] === 'p:';
        return [`h:${host}`, ...(trailingSlashWasAdded ? encodedPaths.slice(1) : encodedPaths), ...(search !== '' ? [`q:${search.substring(1)}`] : [])]
            .join('/');
      }

      const extractEventValue = (setter) => ({target: {value}}) => setter(value)

      const SearchBar = styled('input')`
        font-size: 24px;
        width: 80%;
      `;
      const SearchButton = styled('button')`
        font-size: 24px;
      `;
      function urlToEncodedUrl(url) {
        const {host, pathname, query = ''} = new URL(url)
        return btoa(`${host}${pathname}${query}`)
      }
      const Page = ({encodedUrl, children}) => {
        const [searchTerm, setSearchTerm] = useState(encodedUrlToModuleUrlWithProtocol(encodedUrl))
        function search(event) {
          event.preventDefault();
          route(`/module/${urlToEncodedUrl(searchTerm)}`)
        }
        return html`
          <h1><a href="/">esmspy<//><//>
          <form onSubmit=${search}>
            <${SearchBar}
              type="text"
              placeholder="https://.../uniq.js"
              value=${searchTerm}
              onInput=${extractEventValue(setSearchTerm)}
            />
            <${SearchButton} type="submit">Search<//>
          <//>
          ${children}
        `
      }
      const HomePage = () => {
        return html`<${Page}>
        <//>
        `
      }

      function SnapshotSelector({encodedUrl, snapshot}) {
        const [state, setState] = useState('loading index')
        const [snapshots, setSnapshots] = useState([])
        useEffect(() => {
          (async () => {
            setState('loading index')
            const storagePath = encodedUrlToStoragePath(encodedUrl)
            const response = await fetch(`https://esmspymodules.blob.core.windows.net/$web/${storagePath}/index`)
            if (response.ok) {
              const snapshots = (await response.text()).split('\n').filter(Boolean)
              setSnapshots(snapshots)
              if (!snapshot) {
                route(`/module/${encodedUrl}/${snapshots[0]}`, true)
              }
              setState('index loaded')
            } else {
              setState('failed to load index')
            }
          })()
        }, [encodedUrl])

        if (state === 'loading index') {
          return html`<p>Loading...<//>`
        }
        if (state === 'failed to load index') {
          return html`<p>Failed to load index. Check your internet.<//>`
        }
        return html`
          <h2>sha256 snapshots<//>
          <ul>
            ${snapshots.map((s) => html`<li key=${s}>
              <a href="/module/${encodedUrl}/${s}">${s === snapshot ? html`<b>${s}<//>` : s}<//>
            <//>`)}
          <//>
        `
      }

      function encodedUrlToModuleUrlWithProtocol(encodedUrl) {
        const moduleUrl = atob(encodedUrl)
        return`https://${moduleUrl}`;
      }
      function encodedUrlToStoragePath(encodedUrl) {
        const moduleUrlWithProtocol = encodedUrlToModuleUrlWithProtocol(encodedUrl)
        return urlToStoragePath(moduleUrlWithProtocol)
      }
      const ModulePage = ({encodedUrl, snapshot}) => {
        const [state, setState] = useState('loading snapshot')
        const [module, setModule] = useState({})

        useEffect(() => {
          if (!snapshot) {
            return;
          }
          (async () => {
            setState('loading snapshot')
            const storagePath = encodedUrlToStoragePath(encodedUrl)
            const response = await fetch(`https://esmspymodules.blob.core.windows.net/$web/${storagePath}/${snapshot}`)
            if (response.ok) {
              setModule(await response.json())
              setState('snapshot loaded')
            } else {
              setState('failed to load snapshot')
            }
          })()
        }, [snapshot])

        if (state === 'index loaded' || state === 'loading snapshot') {
          return html`<${Page} encodedUrl=${encodedUrl}>
            <${SnapshotSelector}
              encodedUrl=${encodedUrl}
              snapshot=${snapshot}
            />
            <p>Loading...<//>
          <//>`
        }
        if (state === 'failed to load snapshot') {
          return html`<${Page} encodedUrl=${encodedUrl}>
            <${SnapshotSelector}
              encodedUrl=${encodedUrl}
              snapshot=${snapshot}
            />
            <p>Failed to load snapshot. Check your internet.<//>
          <//>`
        }
        if (module.type !== 'snapshot') {
          return html`<${Page} encodedUrl=${encodedUrl}>
            <${SnapshotSelector}
              encodedUrl=${encodedUrl}
              snapshot=${snapshot}
            />
            <p>Unsupported type ${module.type}<//>
          <//>`
        }
        return html`<${Page} encodedUrl=${encodedUrl}>
          <${SnapshotSelector}
            encodedUrl=${encodedUrl}
            snapshot=${snapshot}
          />
          <dl>
            <dt>source<//>
            <dd><a href="${module.url}" native>${module.url}<//><//>
            <dt>size<//>
            <dd>${PrettyBytes(module.size)}<//>
          <//>
          <h2>imports<//>
          <ul>
            ${module.imports.map(({url, names}) => {
              const {host, pathname, query = ''} = new URL(url)
              return html`<li key=${url}>
                <a href="/module/${urlToEncodedUrl(url)}">${url}<//>
                <ul>
                  ${names.map((name) => html`<li>${name}<//>`)}
                <//>
              <//>`
            })}
          <//>
          <h2>exports<//>
          <ul>
            ${module.exports.map((e) => html`<li>${e}<//>`)}
          <//>
        <//>`;
      }

      const NotFoundPage = () => {
        return html`<${Page}>
          <h2>How did you even get here?<//>
        <//>
        `;
      }

      const App = () => {
        return html`
          <${Router}>
            <${HomePage} path="/"/>
            <${ModulePage} path="/module/:encodedUrl/:snapshot?"/>
            <${NotFoundPage} default />
          <//>
        `
      }
      render(html`<${App}/>`, document.body)
    </script>
  </body>
</html>
